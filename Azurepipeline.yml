trigger:
  none
# - main
# - FB   #manual
# - '*'
  # branches:
  #     include:
  #       - main
  #       - FB
pool:
  vmImage: 'windows-latest'

variables:
  buildConfiguration: 'Release'
stages:  
- stage: Build
  displayName: Application Check Out and Build
  jobs:
  - job: Build
    displayName: Install .Net
    steps:
      # 1. Checkout repository with full history
      - checkout: self
        fetchDepth: 0
          
      - task: UseDotNet@2
        inputs:
              packageType: 'sdk'
              version: '6.x'  

         
      - task: NuGetCommand@2
        inputs:
          command: 'restore'
          restoreSolution: '**/*.sln'

          # 4. Build the solution
      - task: VSBuild@1
        inputs:
          solution: '**/*.sln'
          msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=FileSystem /p:publishUrl=$(Build.ArtifactStagingDirectory)'
          configuration: '$(buildConfiguration)'
      - task: PublishBuildArtifacts@1
        inputs:
          pathToPublish: '$(Build.ArtifactStagingDirectory)/Package'
          artifactName: 'Package'
          publishLocation: 'Container'   
       # - task: CopyFilesOverSSH@0
       #   inputs:
       #    sshEndpoint: 'sshsecond'  
       #    sourceFolder: '$(Pipeline.Workspace)/Package'
       #    contents: '**'  # it Keeps all files and subdirectories
       #    targetFolder: 'C:/Users/harsha/sample_dotnetapp_ADOproject1-main'  # Target root directory
       #    cleanTargetFolder: false
       #    overwrite: true   
          
#       - task: PowerShell@2
#         inputs:
#               targetType: 'inline'
#               script: |
#                 echo "Preparing modified files for deployment..."

#                 # Create the artifact directory
#                 $artifactDir = "$(Build.ArtifactStagingDirectory)/ModifiedFiles"
#                 New-Item -ItemType Directory -Force -Path $artifactDir

#                 # Get list of all modified files
#                 $modifiedFiles = git diff --name-only HEAD~1 HEAD

#                 foreach ($file in $modifiedFiles) {
#                   Write-Host "Processing $file..."

#                   # Check if the file is in the 'DLL' folder
#                   if ($file -like "DLL/*") {
#                     # Process only .dll files in the 'DLL' folder
#                     if ($file -like "*.dll") {
#                       Write-Host "Including DLL file: $file"
#                     } else {
#                       Write-Host "Skipping non-DLL file in 'DLL' folder: $file"
#                       continue
#                     }
#                   }

#                   # Ensure the file exists (in case of deleted files)
#                   if (Test-Path -Path $file) {
#                     # Get the full relative directory structure
#                     $destinationPath = Join-Path -Path $artifactDir -ChildPath $file
#                     $destinationFolder = Split-Path -Parent $destinationPath

#                     # Create the directory structure
#                     New-Item -ItemType Directory -Force -Path $destinationFolder

#                     # Copy the file
#                     Copy-Item -Path $file -Destination $destinationPath -Force
#                   } else {
#                     Write-Host "File $file does not exist, skipping."
#                   }
#                 }
#       - task: PublishBuildArtifacts@1
#         inputs:
#           pathToPublish: '$(Build.ArtifactStagingDirectory)/ModifiedFiles'
#           artifactName: 'ModifiedFiles'
#           publishLocation: 'Container'

# - stage: CI
#   jobs:
#     - deployment: CopyFilesDeployment
#       displayName: "take a backup"
#       environment:
#         name: secondenv  # Environment name in Azure DevOps
#         resourceName: harshaVMwindow  # Resource name for your Windows server to be deployed
#         resourceType: virtualMachine  
#       pool:
#         vmImage: 'windows-latest'  
#       strategy:
#         runOnce:
#           deploy:
#             steps:
#             - task: PowerShell@2
#               displayName: "Copy files into date-based folder"
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Define Source and Destination
#                   $SourceFolder = "C:\Users\harsha\sample_dotnetapp_ADOproject1-main"
#                   $TargetFolder = "C:\Users\harsha\ERMS"
 
#                   # Get current date in yyyy-MM-dd format
#                   $DateFolderName = "backup-" + (Get-Date).ToString("yyyy-MM-dd-HH-mm-ss")
#                   $DateTargetFolder = Join-Path -Path $TargetFolder -ChildPath $DateFolderName
 
#                   # Check if Source Folder Exists
#                   if (Test-Path -Path $SourceFolder) {
#                       # Create Target Date Folder if it doesn't exist
#                       if (!(Test-Path -Path $DateTargetFolder)) {
#                           New-Item -ItemType Directory -Path $DateTargetFolder | Out-Null
#                       }
 
#                       # Copy Files into Date-based Folder
#                       Copy-Item -Path "$SourceFolder\*" -Destination $DateTargetFolder -Recurse -Force
#                       Write-Host "Files copied successfully to $DateTargetFolder."
#                       } else {
#                       Write-Host "Source folder does not exist. Skipping file copy." 
#                       }   
# - stage: Deploy
#   displayName: deploy modified changes
#   jobs:
#   - job: Deploy
#     displayName: Deploy over ssh into server
#     steps: 
#       - task: DownloadPipelineArtifact@2
#         inputs:
#           artifactName: 'ModifiedFiles'
#           targetPath: '$(Pipeline.Workspace)/ModifiedFiles'
#       - task: CopyFilesOverSSH@0
#         inputs:
#           sshEndpoint: 'sshsecond'  
#           sourceFolder: '$(Pipeline.Workspace)/ModifiedFiles'
#           contents: '**'  # it Keeps all files and subdirectories
#           targetFolder: 'C:/Users/harsha/sample_dotnetapp_ADOproject1-main'  # Target root directory
#           cleanTargetFolder: false
#           overwrite: true                                  
